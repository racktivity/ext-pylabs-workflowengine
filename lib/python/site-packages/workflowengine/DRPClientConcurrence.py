#!/opt/qbase3/bin/python
#vim:fdl=0:
if __name__=='__main__':
    from pymonkey.InitBase import q
else:
    from pymonkey import q

from concurrence import Tasklet, Message, dispatch

import osis
import osis.client
from osis.model.serializers import ThriftSerializer
from osis.client.local import LocalTransport
from osis.client.xmlrpc import XMLRPCTransport
import osis.store.OsisDB
import osis.store.OsisConnection
from osis.store.OsisFilterObject import OsisFilterObject

from workflowengine.Exceptions import WFLException

#----------------------------------------------------------
# PG8000 Concurrence driver to be move to osis
#----------------------------------------------------------
import uuid
import datetime

class PG8000ConnectionResult(object):
    def __init__(self,desc,r):
        self.desc=desc
        self.r=r
    def getresult(self):
        return self.r
    def dictresult(self):
        def pgConvert(v):
            # Return same output a pymonkey DBConnection
            if v.__class__ == datetime.datetime:
                v = v.isoformat().replace('T', ' ')
            return v
        result=[dict([(self.desc[j][0], pgConvert(i[j])) for j in range(len(self.desc))]) for i in self.r]
        return result

def pg8000_uuid_in(s,**kwargs):
    return str(uuid.UUID(bytes=s))

class PG8000Connection(object):
    def __init__(self,ip,db,login,passwd):
        from pg8000 import DBAPI
        import ConcurrenceSocket
        import pg8000.interface
        import pg8000.protocol

        pg8000.interface.socket = ConcurrenceSocket.stdsocket
        pg8000.protocol.socket = ConcurrenceSocket.stdsocket

        #print pg8000.interface.socket
        #print pg8000.protocol.socket

        import pg8000.types
        # pg8000 doesn't support uuid
        pg8000.types.pg_types[2950]={"bin_in": pg8000_uuid_in}
        # convert unknown type to string
        pg8000.types.pg_types[705] ={"bin_in": pg8000.types.varcharin} # TEXT type
        self.pg8conn = DBAPI.connect(user=login, host=ip, database=db, password=passwd)

    def sqlexecute(self,*l):
        #q.logger.log("PG8000Connection.sqlexecute",l)
        # PG8000 does noet support %
        l = (q.replace('%', '%%') for q in l)
        # Ugly part I
        t = [v for v in l]
        l = (v for v in t)
        cursor=self.pg8conn.cursor()
        #q.logger.log("PG8000Connection.sqlexecute cursor.execute PRE")
        cursor.execute(*l)
        #q.logger.log("PG8000Connection.sqlexecute cursor.execute POST")
        desc=cursor.description
        # Check of we have a statement which returns a dataset
        # @todo: How can we improve this?
        # Ugly part II
        has_result = bool([True for v in t if v.strip().lower().startswith('select')])
        l = []
        if has_result:
            l=[i for i in cursor]
        #q.logger.log("PG8000Connection.sqlexecute commit PRE")
        self.pg8conn.commit()
        #q.logger.log("PG8000Connection.sqlexecute commit POST")
        r=PG8000ConnectionResult(desc,l)
        #q.logger.log("PG8000Connection.return",l)
        return r

    def listColumns(self,tablename,tablespace=""):
        return self._get_attnames(tablename if not tablespace else "%s.%s"%(tablespace, tablename))

    def _get_attnames(self, cl):
        cl = tuple(cl.split('.'))
        t = {}
        q=self.sqlexecute("SELECT pg_attribute.attname,"
            " pg_type.typname FROM pg_class"
            " JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid"
            " JOIN pg_attribute ON pg_attribute.attrelid = pg_class.oid"
            " JOIN pg_type ON pg_type.oid = pg_attribute.atttypid"
            " WHERE pg_namespace.nspname = '%s' AND pg_class.relname = '%s'"
            " AND (pg_attribute.attnum > 0 or pg_attribute.attname = 'oid')"
            " AND pg_attribute.attisdropped = 'f'"
                % cl).getresult()
        for att, typ in q:
            att=str(att)
            if typ.startswith('bool'):
                t[att] = 'bool'
            elif typ.startswith('abstime') or typ.startswith('date') or typ.startswith('interval'):
                t[att] = 'date'
            elif typ.startswith('timestamp'):
                t[att] = 'datetime'
            elif typ.startswith('money'):
                t[att] = 'money'
            elif typ.startswith('numeric'):
                t[att] = 'num'
            elif typ.startswith('float'):
                t[att] = 'float'
            elif typ.startswith('int') or typ.startswith('oid'):
                t[att] = 'int'
            elif typ.startswith('uuid'):
                t[att] = 'uuid'
            else:
                t[att] = 'text'
        #self.__db._attnames[qcl] = t # cache it
        return t

#----------------------------------------------------------
# DBWrapper Concurrence singletion tasklet and osis wrapper
#----------------------------------------------------------

DBWrapper_tasklet = None

class MSG_QUERY_CALL(Message):
    pass

class MSG_QUERY_RETURN(Message):
    pass

class MSG_QUERY_EXCEPTION(Message):
    pass

def DBWrapper_task(target):
    #q.logger.log("making pymonkey dbconnection singleton, done, looping")
    for msg, args, kwargs in Tasklet.receive():
        caller = args[0]
        mname = args[1]
        args = args[2:]
        if msg.match(MSG_QUERY_CALL):
            try:
                #q.logger.log("DBwrapper query",args,kwargs)
                q.logger.log("DBwrapper query %r"%(args,))
                r=getattr(target,mname).__call__(*args, **kwargs)
                q.logger.log("DBwrapper query done")
                #q.logger.log("DBwrapper query DONE",r)
            except Exception, e:
                MSG_QUERY_EXCEPTION.send(caller)(e)
            else:
                MSG_QUERY_RETURN.send(caller)(r)

class DBWrapperMethod(object):
    def __init__(self,mname):
        self.mname=mname
    def __call__(self,*args,**kwargs):
        #q.logger.log("DBWrap __call__ recv",args,kwargs)
        MSG_QUERY_CALL.send(DBWrapper_tasklet)(Tasklet.current(),self.mname, *args, **kwargs)
        (msg, args, kwargs) = Tasklet.receive().next()
        r=args[0]
        if msg.match(MSG_QUERY_RETURN):
            return r
        elif msg.match(MSG_QUERY_EXCEPTION):
            raise r

class DBWrapper(object):
    def __getattribute__(self,name):
        return DBWrapperMethod(name)

class OsisConcurrenceConnection(osis.store.OsisConnection.OsisConnectionGeneric):
    def __init__(self):
        osis.store.OsisConnection.OsisConnectionGeneric.__init__(self)
        self._dbConn = DBWrapper()
    def connect(self, ip, db, login, passwd):
        pass

def getConnection(self, name, usePG8000=True):
    return OsisConcurrenceConnection()

def init():
    global DBWrapper_tasklet
    from pymonkey.db.DBConnection import DBConnection
    #c=DBConnection('127.0.0.1','osis','qbase','rooter')
    c=PG8000Connection('127.0.0.1','osis','qbase','rooter')
    DBWrapper_tasklet=Tasklet.new(DBWrapper_task)(c)
    osis.store.OsisDB.OsisDB.getConnection=getConnection
    q.drp=DRPClient()

#----------------------------------------------------------
# DrpClient
#----------------------------------------------------------

class DRPClient():
    __shared_state = {}
    def __init__(self):
        self.__dict__ = self.__shared_state
        if not hasattr(self, 'initialized'):
            self.__initialize()
            setattr(self, 'initialized', True)
    def __initialize(self):
        osis.init(q.system.fs.joinPaths(q.dirs.baseDir, 'libexec','osis'))
        c = osis.client.OsisConnection(LocalTransport('/opt/qbase3/apps/applicationserver/services/osis_service/tasklets'), ThriftSerializer)
        self.__connection = c
        from osis import ROOTOBJECT_TYPES as types
        for type in types.itervalues():
            name = getattr(type, 'OSIS_TYPE_NAME', type.__name__.lower())
            setattr(self, name, getattr(self.__connection, name))

    @staticmethod
    def getFilterObject():
        return OsisFilterObject()

#----------------------------------------------------------
# Drp test
#----------------------------------------------------------

def test():
    print "test maintasklet"
    init()
#    print q
#    print q.drp
#    print q.drp.clouduser.get('1')
    c=DBWrapper()
    q.logger.log('--query2 PRE')
    print c.sqlexecute("select * from only job.main where guid='3c9f4267-d226-4b02-9a6a-4c4fa1240f18'").dictresult()
    q.logger.log('--query2 POST')

    q.logger.log('--query3 PRE')
    print c.sqlexecute("select * from only job.main where guid='3c9f4267-d226-4b02-9a6a-4c4fa1240f18'").dictresult()
    q.logger.log('--query3 POST')

if __name__=='__main__':
    #import  ConcurrenceSocket
    #ConcurrenceSocket.install()
    q.drp
    #q.logger.log('--query1 PRE')
    #print c.sqlexecute("select * from only job.main where guid='3c9f4267-d226-4b02-9a6a-4c4fa1240f18'").dictresult()
    #q.logger.log('--query1 POST')
    #print c._get_attnames('job.main')
    c=PG8000Connection('127.0.0.1','osis','qbase','rooter')
    print c.listColumns('job.main')
    dispatch(test)

