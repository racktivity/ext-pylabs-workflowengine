#!/opt/qbase3/bin/python
#vim:fdl=0:
if __name__=='__main__':
    from pymonkey.InitBase import q
else:
    from pymonkey import q

from concurrence import Tasklet, Message, dispatch

import osis
import osis.client
from osis.model.serializers import ThriftSerializer
from osis.client.local import LocalTransport
from osis.client.xmlrpc import XMLRPCTransport
import osis.store.OsisDB
import osis.store.OsisConnection
from osis.store.OsisFilterObject import OsisFilterObject
#import osis.store.PG8000Connection

from workflowengine.Exceptions import WFLException

#----------------------------------------------------------
# PG8000 Concurrence driver
#----------------------------------------------------------
import uuid
import datetime

class PG8000ConnectionResult(object):
    def __init__(self,desc,r):
        self.desc=desc
        self.r=r
    def getresult(self):
        return self.r
    def dictresult(self):
        def pgConvert(v):
            # Return same output a pymonkey DBConnection
            if v.__class__ == datetime.datetime:
                v = v.isoformat().replace('T', ' ')
            return v
        result=[dict([(self.desc[j][0], pgConvert(i[j])) for j in range(len(self.desc))]) for i in self.r]
        return result

def pg8000_uuid_in(s,**kwargs):
    return str(uuid.UUID(bytes=s))

class PG8000Connection(object):
    def __init__(self,ip,db,login,passwd):
        from pg8000 import DBAPI
        import ConcurrenceSocket
        import pg8000.interface
        import pg8000.protocol

        pg8000.interface.socket = ConcurrenceSocket.stdsocket
        pg8000.protocol.socket = ConcurrenceSocket.stdsocket

        #print pg8000.interface.socket
        #print pg8000.protocol.socket

        import pg8000.types
        # pg8000 doesn't support uuid
        pg8000.types.pg_types[2950]={"bin_in": pg8000_uuid_in}
        # convert unknown type to string
        pg8000.types.pg_types[705] ={"bin_in": pg8000.types.varcharin} # TEXT type
        self.pg8conn = DBAPI.connect(user=login, host=ip, database=db, password=passwd)

    def sqlexecute(self,*l):
        q.logger.log("PG8000Connection.sqlexecute",l)
        # PG8000 does noet support %
        l = (q.replace('%', '%%') for q in l)
        # Ugly part I
        t = [v for v in l]
        l = (v for v in t)
        cursor=self.pg8conn.cursor()
        q.logger.log("PG8000Connection.sqlexecute cursor.execute PRE")
        cursor.execute(*l)
        q.logger.log("PG8000Connection.sqlexecute cursor.execute POST")
        desc=cursor.description
        # Check of we have a statement which returns a dataset
        # @todo: How can we improve this?
        # Ugly part II
        has_result = bool([True for v in t if v.strip().lower().startswith('select')])
        l = []
        if has_result:
            l=[i for i in cursor]
        q.logger.log("PG8000Connection.sqlexecute commit PRE")
        self.pg8conn.commit()
        q.logger.log("PG8000Connection.sqlexecute commit POST")
        r=PG8000ConnectionResult(desc,l)
        q.logger.log("PG8000Connection.return",l)
        return r

    def _get_attnames(self, cl):
        cl = tuple(cl.split('.'))
        t = {}
        q=self.sqlexecute("SELECT pg_attribute.attname,"
            " pg_type.typname FROM pg_class"
            " JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid"
            " JOIN pg_attribute ON pg_attribute.attrelid = pg_class.oid"
            " JOIN pg_type ON pg_type.oid = pg_attribute.atttypid"
            " WHERE pg_namespace.nspname = '%s' AND pg_class.relname = '%s'"
            " AND (pg_attribute.attnum > 0 or pg_attribute.attname = 'oid')"
            " AND pg_attribute.attisdropped = 'f'"
                % cl).getresult()
        for att, typ in q:
            att=str(att)
            if typ.startswith('bool'):
                t[att] = 'bool'
            elif typ.startswith('abstime') or typ.startswith('date') or typ.startswith('interval'):
                t[att] = 'date'
            elif typ.startswith('timestamp'):
                t[att] = 'datetime'
            elif typ.startswith('money'):
                t[att] = 'money'
            elif typ.startswith('numeric'):
                t[att] = 'num'
            elif typ.startswith('float'):
                t[att] = 'float'
            elif typ.startswith('int') or typ.startswith('oid'):
                t[att] = 'int'
            elif typ.startswith('uuid'):
                t[att] = 'uuid'
            else:
                t[att] = 'text'
        #self.__db._attnames[qcl] = t # cache it
        return t

#----------------------------------------------------------
# DBWrapper Concurrence singletion tasklet and osis wrapper
#----------------------------------------------------------

DBWrapper_tasklet = None

class MSG_QUERY_CALL(Message):
    pass

class MSG_QUERY_RETURN(Message):
    pass

class MSG_QUERY_EXCEPTION(Message):
    pass

def DBWrapper_task(target):
    q.logger.log("making pymonkey dbconnection singleton, done, looping")
    for msg, args, kwargs in Tasklet.receive():
        caller = args[0]
        mname = args[1]
        args = args[2:]
        if msg.match(MSG_QUERY_CALL):
            try:
                q.logger.log("DBwrapper query",args,kwargs)
                r=getattr(target,mname).__call__(*args, **kwargs)
                q.logger.log("DBwrapper query DONE",r)
            except Exception, e:
                MSG_QUERY_EXCEPTION.send(caller)(e)
            else:
                MSG_QUERY_RETURN.send(caller)(r)

class DBWrapperMethod(object):
    def __init__(self,mname):
        self.mname=mname
    def __call__(self,*args,**kwargs):
        q.logger.log("DBWrap __call__ recv",args,kwargs)
        MSG_QUERY_CALL.send(DBWrapper_tasklet)(Tasklet.current(),self.mname, *args, **kwargs)
        (msg, args, kwargs) = Tasklet.receive().next()
        r=args[0]
        if msg.match(MSG_QUERY_RETURN):
            return r
        elif msg.match(MSG_QUERY_EXCEPTION):
            raise r

class DBWrapper(object):
    def __getattribute__(self,name):
        return DBWrapperMethod(name)

class OsisConcurrenceConnection(osis.store.OsisConnection.OsisConnectionGeneric):
    def __init__(self):
        osis.store.OsisConnection.OsisConnectionGeneric.__init__(self)
        self._dbConn = DBWrapper()
    def connect(self, ip, db, login, passwd):
        pass

def getConnection(self, name, usePG8000=True):
    return OsisConcurrenceConnection()

def init():
    global DBWrapper_tasklet
    from pymonkey.db.DBConnection import DBConnection
    #c=DBConnection('127.0.0.1','osis','qbase','rooter')
    c=PG8000Connection('127.0.0.1','osis','qbase','rooter')
    DBWrapper_tasklet=Tasklet.new(DBWrapper_task)(c)
    osis.store.OsisDB.OsisDB.getConnection=getConnection
    q.drp=DRPClient()

#----------------------------------------------------------
# DrpClient
#----------------------------------------------------------

class DRPClient():
    __shared_state = {}
    def __init__(self):
        self.__dict__ = self.__shared_state
        if not hasattr(self, 'initialized'):
            self.__initialize()
            setattr(self, 'initialized', True)
    def __initialize(self):
        osis.init(q.system.fs.joinPaths(q.dirs.baseDir, 'libexec','osis'))
        c = osis.client.OsisConnection(LocalTransport('/opt/qbase3/apps/applicationserver/services/osis_service/tasklets'), ThriftSerializer)
        self.__connection = c
        from osis import ROOTOBJECT_TYPES as types
        for type in types.itervalues():
            name = getattr(type, 'OSIS_TYPE_NAME', type.__name__.lower())
            setattr(self, name, getattr(self.__connection, name))

    @staticmethod
    def getFilterObject():
        return OsisFilterObject()

#----------------------------------------------------------
# Init to be called by the main_tasklet
#----------------------------------------------------------


#----------------------------------------------------------
# Drp test
#----------------------------------------------------------

def test():
    print "test maintasklet"
    init()
#    print q
#    print q.drp
#    print q.drp.clouduser.get('1')
    c=DBWrapper()
    q.logger.log('--query2 PRE')
    print c.sqlexecute("select * from only job.main where guid='3c9f4267-d226-4b02-9a6a-4c4fa1240f18'").dictresult()
    q.logger.log('--query2 POST')

    q.logger.log('--query3 PRE')
    print c.sqlexecute("select * from only job.main where guid='3c9f4267-d226-4b02-9a6a-4c4fa1240f18'").dictresult()
    q.logger.log('--query3 POST')

if __name__=='__main__':
    #import  ConcurrenceSocket
    #ConcurrenceSocket.install()
    q.drp
    #c=PG8000Connection('127.0.0.1','osis','qbase','rooter')
    #q.logger.log('--query1 PRE')
    #print c.sqlexecute("select * from only job.main where guid='3c9f4267-d226-4b02-9a6a-4c4fa1240f18'").dictresult()
    #q.logger.log('--query1 POST')
    #print c._get_attnames('job.main')
    dispatch(test)

