#!/opt/qbase3/bin/python
#vim:fdl=0:
if __name__=='__main__':
    from pymonkey.InitBase import q
else:
    from pymonkey import q

from concurrence import Tasklet, Message, dispatch

import osis
import osis.client
from osis.model.serializers import ThriftSerializer
from osis.client.local import LocalTransport
from osis.client.xmlrpc import XMLRPCTransport
import osis.store.OsisDB
import osis.store.OsisConnection
from osis.store.OsisFilterObject import OsisFilterObject
#import osis.store.PG8000Connection

from workflowengine.Exceptions import WFLException

#----------------------------------------------------------
# PG8000 Concurrence driver
#----------------------------------------------------------
import uuid
import datetime

class PG8000ConnectionResult(object):
    def __init__(self,desc,r):
        self.desc=desc
        self.r=r
    def getresult(self):
        return self.r
    def dictresult(self):
        def pgConvert(v):
            # Return same output a pymonkey DBConnection
            if v.__class__ == datetime.datetime:
                v = v.isoformat().replace('T', ' ')
            return v
        result=[dict([(self.desc[j][0], pgConvert(i[j])) for j in range(len(self.desc))]) for i in self.r]
        return result

def pg8000_uuid_in(s,**kwargs):
    return str(uuid.UUID(bytes=s))

class PG8000Connection(object):
    def __init__(self,ip,db,login,passwd):
        from pg8000 import DBAPI
        import ConcurrenceSocket
        import pg8000.interface
        import pg8000.protocol

        pg8000.interface.socket = ConcurrenceSocket.stdsocket
        pg8000.protocol.socket = ConcurrenceSocket.stdsocket

        #print pg8000.interface.socket
        #print pg8000.protocol.socket

        import pg8000.types
        # pg8000 doesn't support uuid
        pg8000.types.pg_types[2950]={"bin_in": pg8000_uuid_in}
        # convert unknown type to string
        pg8000.types.pg_types[705] ={"bin_in": pg8000.types.varcharin} # TEXT type
        self.pg8conn = DBAPI.connect(user=login, host=ip, database=db, password=passwd)

    def sqlexecute(self,*l):
        q.logger.log("PG8000Connection.sqlexecute",l)
        # PG8000 does noet support %
        l = (q.replace('%', '%%') for q in l)
        # Ugly part I
        t = [v for v in l]
        l = (v for v in t)
        cursor=self.pg8conn.cursor()
        q.logger.log("PG8000Connection.sqlexecute cursor.execute PRE")
        cursor.execute(*l)
        q.logger.log("PG8000Connection.sqlexecute cursor.execute POST")
        desc=cursor.description
        # Check of we have a statement which returns a dataset
        # @todo: How can we improve this?
        # Ugly part II
        has_result = bool([True for v in t if v.strip().lower().startswith('select')])
        l = []
        if has_result:
            l=[i for i in cursor]
        q.logger.log("PG8000Connection.sqlexecute commit PRE")
        self.pg8conn.commit()
        q.logger.log("PG8000Connection.sqlexecute commit POST")
        r=PG8000ConnectionResult(desc,l)
        q.logger.log("PG8000Connection.return",l)
        return r

#----------------------------------------------------------
# PG8000 Concurrence singletion tasklet and osis wrapper
#----------------------------------------------------------

class MSG_QUERY_CALL(Message):
    pass

class MSG_QUERY_RETURN(Message):
    pass

class MSG_QUERY_EXCEPTION(Message):
    pass

#def query_task():
#    q.logger.log("query_task connect")
#    #c=osis.store.PG8000Connection.PG8000Connection('127.0.0.1','osis','qbase','rooter')
#    c=PG8000Connection('127.0.0.1','osis','qbase','rooter')
#    q.logger.log("query_task loop")
#    for msg, args, kwargs in Tasklet.receive():
#        caller = args[0]
#        args = args[1:]
#        if msg.match(MSG_QUERY_CALL):
#            try:
#                #q.logger.log("--PG800Connection.sqlexecute",args,kwargs)
#                r=c.sqlexecute(*args, **kwargs)
#                #q.logger.log("--PG800Connection.sqlexecute_RETURN")
#            except Exception, e:
#                print "pg8000_query_task Exception",e
#                MSG_QUERY_EXCEPTION.send(caller)(e)
#            else:
#                MSG_QUERY_RETURN.send(caller)(r)
#
#query_tasklet = None
#
#class ConcurrencePG8000Connection:
#    def __init__(self):
#        pass
#    def sqlexecute(self, *args, **kwargs):
#        #q.logger.log("ConcurrencePG8000Connection.sqlexecute send",args,kwargs)
#        MSG_QUERY_CALL.send(query_tasklet)(Tasklet.current(), *args, **kwargs)
#        (msg, args, kwargs) = Tasklet.receive().next()
#        r=args[0]
#        if msg.match(MSG_QUERY_RETURN):
#            #q.logger.log("ConcurrencePG8000Connection.sqlexecute recv",r)
#            return r
#        elif msg.match(MSG_QUERY_EXCEPTION):
#            #q.logger.log("ConcurrencePG8000Connection.sqlexecute recv",r)
#            raise r
#
#class OsisConcurrenceConnection(osis.store.OsisConnection.OsisConnectionGeneric):
#    def __init__(self):
#        osis.store.OsisConnection.OsisConnectionGeneric.__init__(self)
#        self._dbConn = ConcurrencePG8000Connection()
#    def connect(self, ip, db, login, passwd):
#        pass
#
#def getConnection(self, name, usePG8000=True):
#    return OsisConcurrenceConnection()

#----------------------------------------------------------
# Pygresql Concurrence singleton tasklet and osis wrapper
#----------------------------------------------------------
query_object = None
query_tasklet = None

def query_task():
    #c=osis.store.PG8000Connection.PG8000Connection('127.0.0.1','osis','qbase','rooter')
    q.logger.log("making pymonkey dbconnection singleton")
    from pymonkey.db.DBConnection import DBConnection
    query_object = DBConnection('127.0.0.1','osis','qbase','rooter') # load osisdb main()
    q.logger.log("making pymonkey dbconnection singleton, done, looping")
    for msg, args, kwargs in Tasklet.receive():
        caller = args[0]
        mname = args[1]
        args = args[2:]
        if msg.match(MSG_QUERY_CALL):
            try:
                q.logger.log("DBwrapper query",args,kwargs)
                r=getattr(query_object,mname).__call__(*args, **kwargs)
                q.logger.log("DBwrapper query DONE",args,kwargs)
            except Exception, e:
                MSG_QUERY_EXCEPTION.send(caller)(e)
            else:
                MSG_QUERY_RETURN.send(caller)(r)

class PymonkeyDBWrapperMethod(object):
    def __init__(self,mname):
        self.mname=mname
    def __call__(self,*args,**kwargs):
        #q.logger.log("Pymonkeydbwrppaezr __call__ recv",args,kwargs)
        MSG_QUERY_CALL.send(query_tasklet)(Tasklet.current(),self.mname, *args, **kwargs)
        (msg, args, kwargs) = Tasklet.receive().next()
        r=args[0]
        if msg.match(MSG_QUERY_RETURN):
            return r
        elif msg.match(MSG_QUERY_EXCEPTION):
            raise r

class PymonkeyDBWrapper(object):
    def __getattribute__(self,name):
        return PymonkeyDBWrapperMethod(name)

class OsisConcurrenceConnection(osis.store.OsisConnection.OsisConnectionGeneric):
    def __init__(self):
        osis.store.OsisConnection.OsisConnectionGeneric.__init__(self)
        self._dbConn = PymonkeyDBWrapper()
    def connect(self, ip, db, login, passwd):
        pass

def getConnection(self, name, usePG8000=True):
    return OsisConcurrenceConnection()

#----------------------------------------------------------
# DrpClient
#----------------------------------------------------------

class DRPClient():
    __shared_state = {}
    def __init__(self):
        self.__dict__ = self.__shared_state
        if not hasattr(self, 'initialized'):
            self.__initialize()
            setattr(self, 'initialized', True)
    def __initialize(self):
        osis.init(q.system.fs.joinPaths(q.dirs.baseDir, 'libexec','osis'))
        c = osis.client.OsisConnection(LocalTransport('/opt/qbase3/apps/applicationserver/services/osis_service/tasklets'), ThriftSerializer)
        self.__connection = c
        from osis import ROOTOBJECT_TYPES as types
        for type in types.itervalues():
            name = getattr(type, 'OSIS_TYPE_NAME', type.__name__.lower())
            setattr(self, name, getattr(self.__connection, name))

    @staticmethod
    def getFilterObject():
        return OsisFilterObject()


#----------------------------------------------------------
# Init to be called by the main_tasklet
#----------------------------------------------------------

def init():
    global query_tasklet
    query_tasklet=Tasklet.new(query_task)()
    osis.store.OsisDB.OsisDB.getConnection=getConnection
    q.drp=DRPClient()

#----------------------------------------------------------
# Drp test
#----------------------------------------------------------

def test():
    print "test maintasklet"
    init()
#    print q
#    print q.drp
#    print q.drp.clouduser.get('1')
#    c=ConcurrencePG8000Connection()
    c=PymonkeyDBWrapper()
    q.logger.log('--query2 PRE')
    print c.sqlexecute("select * from only job.main where guid='3c9f4267-d226-4b02-9a6a-4c4fa1240f18'").dictresult()
    q.logger.log('--query2 POST')

    q.logger.log('--query3 PRE')
    print c.sqlexecute("select * from only job.main where guid='3c9f4267-d226-4b02-9a6a-4c4fa1240f18'").dictresult()
    q.logger.log('--query3 POST')

if __name__=='__main__':
    q.drp
    #c=PG8000Connection('127.0.0.1','osis','qbase','rooter')
    #c=PymonkeyDBWrapper()
    #q.logger.log('--query1 PRE')
    #print c.sqlexecute("select * from only job.main where guid='3c9f4267-d226-4b02-9a6a-4c4fa1240f18'").dictresult()
    #q.logger.log('--query1 POST')

    #import  ConcurrenceSocket
    #ConcurrenceSocket.install()
    dispatch(test)

