import pickle, socket, sys, threading, time

import yaml
from twisted.internet import protocol, reactor

from pymonkey import q, i

ActionManagerTaskletPath = q.system.fs.joinPaths(q.dirs.appDir,'workflowengine','tasklets')
ActorActionTaskletPath = q.system.fs.joinPaths(ActionManagerTaskletPath, 'actor')
RootobjectActionTaskletPath = q.system.fs.joinPaths(ActionManagerTaskletPath, 'rootobject')

class WFLActionManager():
    """
    This implementation of the ActionManager is available to the cloudAPI: only root object actions are available.
    """
    def __init__(self):
        #self.factory = YamlClientFactory(self._receivedData)
        self.config = i.config.workflowengine.getConfig('main')
        #def _do_connect():
        #    reactor.connectTCP('localhost', int(config['port']), self.factory)
        #reactor.callInThread(_do_connect)
        #self.running = {}
        #self.idlock = threading.Lock()
        #self.id = 0

        ##### For synchronous execution ##########
        # Bypass WF?
        from pymonkey.tasklets import TaskletsEngine
        self.__taskletEngine = TaskletsEngine()
        ##create tasklets dir if it doesnt exist
        if not q.system.fs.exists(ActorActionTaskletPath):
            q.system.fs.createDir(ActorActionTaskletPath)
        self.__taskletEngine.addFromPath(ActorActionTaskletPath)
        if not q.system.fs.exists(RootobjectActionTaskletPath):
            q.system.fs.createDir(RootobjectActionTaskletPath)
        self.__taskletEngine.addFromPath(RootobjectActionTaskletPath)
        ##### /For synchronous execution ##########

    def _receivedData(self, data):
        #self.running[data['id']]['return'] = data.get('return')
        #self.running[data['id']]['error'] = data.get('error')
        #self.running[data['id']]['exception'] = data.get('exception')
        #self.running[data['id']]['lock'].release()
        pass

    def startActorAction(self, actorname, actionname, params, executionparams={}, jobguid=None):
        '''
        This action is unavailable.
        @raise ActionUnavailableException: always thrown
        '''
        raise Exception("This Actor actions are not available at the applicationserver level.")

    def startRootobjectAction(self, rootobjectname, actionname, params, executionparams={}, jobguid=None):
        # Default is async
        return self.startRootobjectActionAsynchronous(rootobjectname, actionname, params, executionparams, jobguid)

    def startRootobjectActionAsynchronous(self, rootobjectname, actionname, params, executionparams={}, jobguid=None):
        """
        Send the root object action to the stackless workflowengine over a socket.
        The root object action will wait until the workflowengine returns a result.
        """
        # For backwards compatibility, If called explicitely, don't wait for result 
        if not 'wait' in executionparams:
            executionparams['wait'] = False
        data={'id':1,'rootobjectname':rootobjectname, 'actionname':actionname, 'params':params, 'executionparams':executionparams, 'jobguid':jobguid}
        msg = pickle.dumps(data,-1)
        print "msg: %r"%msg
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(('127.0.0.1', int(self.config['port'])))
        totalsent = 0
        while totalsent < len(msg):
            sent = sock.send(msg[totalsent:])
            totalsent += sent
            if sent == 0:
                raise RuntimeError, "socket connection broken"
        rep = ''
        while 1:
            chunk = sock.recv(8192)
            print "recv %r"%chunk
            rep += chunk
            if chunk == '':
                break
            #if rep.endswith('\n---\n'):
            #    sock.close()
            #    break
        #rep=rep[:-5]
        print "msg,rep: %r %r"%(msg,rep)
        data = pickle.loads(rep)

        #self.factory.sendData()
        #my_lock.acquire()
        ## Wait for receivedData to release the lock
        #my_lock.release()

        #data = self.running.pop(my_id)
        if not data['error']:
            return data['return']
        else:
            raise data['exception']

    def startRootobjectActionSynchronous(self, rootobjectname, actionname, params, executionparams={}, jobguid=None):
        q.logger.log('>>> Executing startRootobjectActionSynchronous : %s %s %s' % (rootobjectname, actionname, params), 1)
        if len(self.__taskletEngine.find(tags=(rootobjectname, actionname), path=RootobjectActionTaskletPath)) == 0:
            raise ActionNotFoundException("RootobjectAction", rootobjectname, actionname)
        self.__taskletEngine.execute(params, tags=(rootobjectname, actionname), path=RootobjectActionTaskletPath)
        result = {'jobguid': None, 'result': params['result']}
        q.logger.log('>>> startRootobjectActionSynchronous returns : %s ' % result, 1)
        return result

